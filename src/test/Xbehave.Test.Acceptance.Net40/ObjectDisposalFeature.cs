// <copyright file="ObjectDisposalFeature.cs" company="xBehave.net contributors">
//  Copyright (c) xBehave.net contributors. All rights reserved.
// </copyright>

#if !V2
#if NET40 || NET45
namespace Xbehave.Test.Acceptance
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.IO;
    using System.Linq;
    using System.Threading;
#if NET45
    using System.Threading.Tasks;
#endif
    using FluentAssertions;
    using Xbehave.Test.Acceptance.Infrastructure;

    // In order to release allocated resources
    // As a developer
    // I want to register objects for disposal after a scenario has run
    public static class ObjectDisposalFeature
    {
        [Background]
        public static void Background()
        {
            "Given no temporary files exist"
                .f(() =>
                {
                    foreach (var path in Directory.EnumerateFiles(Directory.GetCurrentDirectory(), "*.ObjectDisposalFeature"))
                    {
                        File.Delete(path);
                    }
                });
        }

        [Scenario]
        [Example(typeof(AStepWithThreeDisposables))]
        [Example(typeof(AStepWithThreeDisposablesAndATimeout))]
        [Example(typeof(ThreeStepsWithDisposables))]
#if NET45
        [Example(typeof(AnAsyncStepWithThreeDisposables))]
#endif
        public static void ManyDisposablesInASingleStep(Type feature, Result[] results)
        {
            "Given {0}"
                .f(() => { });

            "When running the scenario"
                .f(() => results = feature.RunScenarios());

            "And there should be no failures"
                .f(() => results.Should().ContainItemsAssignableTo<Pass>());

            "And all but the last result should not be generated by a teardown"
                .f(() => results.Reverse().Skip(1).ShouldNotBeTeardowns());

            "And the last result should be generated by a teardown"
                .f(() => results.Last().ShouldBeATeardown());

            "And the disposables should each have been disposed in reverse order"
                .f(() => ShouldBeWrittenInOrder("disposed.3.ObjectDisposalFeature", "disposed.2.ObjectDisposalFeature", "disposed.1.ObjectDisposalFeature"));
        }

        [Scenario]
        public static void ADisposableWhichThrowExceptionsWhenDisposed(Type feature, Result[] results)
        {
            "Given a step with three disposables which throw exceptions when disposed"
                .f(() => feature = typeof(StepWithThreeBadDisposables));

            "When running the scenario"
                .f(() => results = feature.RunScenarios());

            "Then the results should not be empty"
                .f(() => results.Should().NotBeEmpty());

            "And the first n-1 results should not be failures"
                .f(() => results.Reverse().Skip(1).Should().NotContain(result => result is Fail));

            "And the last result should be a failure"
                .f(() => results.Reverse().First().Should().BeOfType<Fail>());

            "And the disposables should be disposed in reverse order"
                .f(() => ShouldBeWrittenInOrder("disposed.3.ObjectDisposalFeature", "disposed.2.ObjectDisposalFeature", "disposed.1.ObjectDisposalFeature"));
        }

#if !V2
        [Scenario]
        public static void DisposablesWhichCreateNewDisposablesWhenDisposed(
            Type feature, Result[] results)
        {
            ("Given a step with disposables which, when disposed," +
                "throw an exception and add more disposables which throw an exception when disposed")
                .f(() => feature = typeof(StepWithThreeRecursiveBadDisposables));

            "When running the scenario"
                .f(() => results = feature.RunScenarios());

            "Then the results should not be empty"
                .f(() => results.Should().NotBeEmpty());

            "And the first n-2 results should not be failures"
                .f(() => results.Reverse().Skip(2).Should().NotContain(result => result is Fail));

            "And the last 2 results should be failures"
                .f(() => results.Reverse().Take(2).Should().ContainItemsAssignableTo<Fail>());

            "And the disposables should be disposed in reverse order"
                .f(() => ShouldBeWrittenInOrder("disposed.3.ObjectDisposalFeature", "disposed.2.ObjectDisposalFeature", "disposed.1.ObjectDisposalFeature"));
        }

        [Scenario]
        public static void MultipleContexts(Type feature, Result[] results)
        {
            "Given a step with a disposable and steps which generate two contexts"
                .f(() => feature = typeof(TwoContexts));

            "When running the scenario"
                .f(() => results = feature.RunScenarios());

            "And there should be no failures"
                .f(() => results.Should().ContainItemsAssignableTo<Pass>());

            "And the disposable should be disposed after each context"
                .f(() => ShouldBeWrittenInOrder("step.1.ObjectDisposalFeature", "disposed.1.ObjectDisposalFeature", "step.2.ObjectDisposalFeature", "disposed.2.ObjectDisposalFeature"));
        }
#endif

        [Scenario]
        [Example(typeof(StepsFollowedByAFailingStep))]
        [Example(typeof(StepFailsToComplete))]
        public static void FailingSteps(Type feature, Result[] results)
        {
            "Given {0}"
                .f(() => { });

            "When running the scenario"
                .f(() => results = feature.RunScenarios());

            "Then there should be one failure"
                .f(() => results.OfType<Fail>().Count().Should().Be(1));

            "And the disposables should be disposed in reverse order"
                .f(() => ShouldBeWrittenInOrder("disposed.3.ObjectDisposalFeature", "disposed.2.ObjectDisposalFeature", "disposed.1.ObjectDisposalFeature"));
        }

        [Scenario]
        public static void DisposablesAndTeardowns(Type feature, Result[] results)
        {
            "Given steps with disposables and teardowns"
                .f(() => feature = typeof(StepsWithDisposablesAndTeardowns));

            "When running the scenario"
                .f(() => results = feature.RunScenarios());

            "And there should be no failures"
                .f(() => results.Should().ContainItemsAssignableTo<Pass>());

            "And the disposables and teardowns should be disposed/executed in reverse order"
                .f(() => ShouldBeWrittenInOrder(
                    "teardown.12.ObjectDisposalFeature",
                    "teardown.11.ObjectDisposalFeature",
                    "teardown.10.ObjectDisposalFeature",
                    "disposed.9.ObjectDisposalFeature",
                    "disposed.8.ObjectDisposalFeature",
                    "disposed.7.ObjectDisposalFeature",
                    "teardown.6.ObjectDisposalFeature",
                    "teardown.5.ObjectDisposalFeature",
                    "teardown.4.ObjectDisposalFeature",
                    "disposed.3.ObjectDisposalFeature",
                    "disposed.2.ObjectDisposalFeature",
                    "disposed.1.ObjectDisposalFeature"));
        }

        private static void ShouldBeWrittenInOrder(params string[] paths)
        {
            Directory.EnumerateFiles(Directory.GetCurrentDirectory(), "*.ObjectDisposalFeature").Select(Path.GetFileName)
                .Should().BeEquivalentTo(paths);

            var writings = paths.Select(s => new { Path = s, Ticks = Read(s) }).ToArray();
            writings.Should().Equal(writings.OrderBy(writing => writing.Ticks));
        }

        private static void ShouldNotBeTeardowns(this IEnumerable<Result> results)
        {
            foreach (var result in results)
            {
                result.DisplayName.Should().NotContainEquivalentOf("(teardown)");
            }
        }

        private static AndConstraint<FluentAssertions.Primitives.StringAssertions> ShouldBeATeardown(this Result result)
        {
            return result.DisplayName.Should().ContainEquivalentOf("(teardown)");
        }

        private static void Write(string path)
        {
            Thread.Sleep(1);
            using (var file = new StreamWriter(path, false))
            {
                file.Write(DateTime.Now.Ticks);
            }
        }

        private static long Read(string path)
        {
            return long.Parse(File.ReadAllText(path));
        }

        private static class AStepWithThreeDisposables
        {
            [Scenario]
            public static void Scenario(
                WritingDisposable disposable0, WritingDisposable disposable1, WritingDisposable disposable2)
            {
                "Given some disposables"
                    .f(c =>
                    {
                        disposable0 = new WritingDisposable(1).Using(c);
                        disposable1 = new WritingDisposable(2).Using(c);
                        disposable2 = new WritingDisposable(3).Using(c);
                    });

                "When using the disposables"
                    .f(() =>
                    {
                        disposable0.Use();
                        disposable1.Use();
                        disposable2.Use();
                    });
            }
        }

        private static class AStepWithThreeDisposablesAndATimeout
        {
            [Scenario]
            public static void Scenario(
                WritingDisposable disposable0, WritingDisposable disposable1, WritingDisposable disposable2)
            {
                "Given some disposables"
                    .f(c =>
                    {
                        disposable0 = new WritingDisposable(1).Using(c);
                        disposable1 = new WritingDisposable(2).Using(c);
                        disposable2 = new WritingDisposable(3).Using(c);
                    })
                    .WithTimeout(Timeout.Infinite);

                "When using the disposables"
                    .f(() =>
                    {
                        disposable0.Use();
                        disposable1.Use();
                        disposable2.Use();
                    });
            }
        }

        private static class StepWithThreeBadDisposables
        {
            [Scenario]
            public static void Scenario(
                WritingDisposable disposable0, WritingDisposable disposable1, WritingDisposable disposable2)
            {
                "Given some disposables"
                    .f(c =>
                    {
                        disposable0 = new BadDisposable(1).Using(c);
                        disposable1 = new BadDisposable(2).Using(c);
                        disposable2 = new BadDisposable(3).Using(c);
                    });

                "When using the disposables"
                    .f(() =>
                    {
                        disposable0.Use();
                        disposable1.Use();
                        disposable2.Use();
                    });
            }
        }

#if !V2
        private static class StepWithThreeRecursiveBadDisposables
        {
            [Scenario]
            public static void Scenario(
                WritingDisposable disposable0, WritingDisposable disposable1, WritingDisposable disposable2)
            {
                "Given some disposables"
                    .f(c =>
                    {
                        disposable0 = new SingleRecursionBadDisposable(1).Using(c);
                        disposable1 = new SingleRecursionBadDisposable(2).Using(c);
                        disposable2 = new SingleRecursionBadDisposable(3).Using(c);
                    });

                "When using the disposables"
                    .f(() =>
                    {
                        disposable0.Use();
                        disposable1.Use();
                        disposable2.Use();
                    });
            }
        }

#endif
        private static class ThreeStepsWithDisposables
        {
            [Scenario]
            public static void Scenario(
                WritingDisposable disposable0, WritingDisposable disposable1, WritingDisposable disposable2)
            {
                "Given a disposable"
                    .f(c => disposable0 = new WritingDisposable(1).Using(c));

                "And another disposable"
                    .f(c => disposable1 = new WritingDisposable(2).Using(c));

                "And another disposable"
                    .f(c => disposable2 = new WritingDisposable(3).Using(c));

                "When using the disposables"
                    .f(() =>
                    {
                        disposable0.Use();
                        disposable1.Use();
                        disposable2.Use();
                    });
            }
        }

#if !V2
        private static class TwoContexts
        {
            private static int context;

            [Scenario]
            public static void Scenario(WritingDisposable disposable)
            {
                "Given a disposable"
                    .f(c =>
                    {
                        context++;
                        Write(string.Concat("step.", context.ToString(CultureInfo.InvariantCulture), ".ObjectDisposalFeature"));
                        disposable = new WritingDisposable(context).Using(c);
                    });

                "When using the disposable"
                    .f(() => disposable.Use());

                "Then something"
                    .f(() => { })
                    .InIsolation();

                "And something"
                    .f(() => { });
            }
        }
#endif

        private static class StepsFollowedByAFailingStep
        {
            [Scenario]
            public static void Scenario(
                WritingDisposable disposable0, WritingDisposable disposable1, WritingDisposable disposable2)
            {
                "Given a disposable"
                    .f(c => disposable0 = new WritingDisposable(1).Using(c));

                "And another disposable"
                    .f(c => disposable1 = new WritingDisposable(2).Using(c));

                "And another disposable"
                    .f(c => disposable2 = new WritingDisposable(3).Using(c));

                "When using the disposables"
                    .f(() =>
                    {
                        disposable0.Use();
                        disposable1.Use();
                        disposable2.Use();
                    });

                "Then something happens"
                    .f(() => 1.Should().Be(0));
            }
        }

        private static class StepFailsToComplete
        {
            [Scenario]
            public static void Scenario()
            {
                "Given some disposables"
                    .f(c =>
                    {
                        new WritingDisposable(1).Using(c);
                        new WritingDisposable(2).Using(c);
                        new WritingDisposable(3).Using(c);
                        throw new InvalidOperationException();
                    });
            }
        }

#if NET45
        private static class AnAsyncStepWithThreeDisposables
        {
            [Scenario]
            public static void Scenario(
                WritingDisposable disposable0, WritingDisposable disposable1, WritingDisposable disposable2)
            {
                "Given some disposables"
                    .f(async c =>
                    {
                        await Task.Yield();
                        disposable0 = new WritingDisposable(1).Using(c);
                        disposable1 = new WritingDisposable(2).Using(c);
                        disposable2 = new WritingDisposable(3).Using(c);
                    });

                "When using the disposables"
                    .f(() =>
                    {
                        disposable0.Use();
                        disposable1.Use();
                        disposable2.Use();
                    });
            }
        }
#endif

        private static class StepsWithDisposablesAndTeardowns
        {
            [Scenario]
            public static void Scenario()
            {
                "Given something"
                    .f(c =>
                    {
                        new WritingDisposable(1).Using(c);
                        new WritingDisposable(2).Using(c);
                        new WritingDisposable(3).Using(c);
                    })
                    .Teardown(() => Write("teardown.4.ObjectDisposalFeature"))
                    .Teardown(() => Write("teardown.5.ObjectDisposalFeature"))
                    .Teardown(() => Write("teardown.6.ObjectDisposalFeature"));

                "And something else"
                    .f(c =>
                    {
                        new WritingDisposable(7).Using(c);
                        new WritingDisposable(8).Using(c);
                        new WritingDisposable(9).Using(c);
                    })
                    .Teardown(() => Write("teardown.10.ObjectDisposalFeature"))
                    .Teardown(() => Write("teardown.11.ObjectDisposalFeature"))
                    .Teardown(() => Write("teardown.12.ObjectDisposalFeature"));
            }
        }

        private class WritingDisposable : IDisposable
        {
            private readonly int number;
            private bool isDisposed;

            public WritingDisposable(int number)
            {
                this.number = number;
            }

            ~WritingDisposable()
            {
                this.Dispose(false);
            }

            public void Use()
            {
                if (this.isDisposed)
                {
                    throw new ObjectDisposedException(this.GetType().FullName);
                }
            }

            public void Dispose()
            {
                this.Dispose(true);
                GC.SuppressFinalize(this);
            }

            protected virtual void Dispose(bool disposing)
            {
                if (disposing)
                {
                    Write(string.Concat("disposed.", this.number.ToString(CultureInfo.InvariantCulture), ".ObjectDisposalFeature"));
                    this.isDisposed = true;
                }
            }
        }

        private sealed class BadDisposable : WritingDisposable
        {
            public BadDisposable(int number)
                : base(number)
            {
            }

            protected override void Dispose(bool disposing)
            {
                base.Dispose(disposing);
                if (disposing)
                {
                    throw new NotImplementedException();
                }
            }
        }

#if !V2
        private sealed class SingleRecursionBadDisposable : WritingDisposable
        {
            public SingleRecursionBadDisposable(int number)
                : base(number)
            {
            }

            protected override void Dispose(bool disposing)
            {
                base.Dispose(disposing);
                if (disposing)
                {
#pragma warning disable 618
                    new BadDisposable(1).Using();
#pragma warning restore 618
                    throw new NotImplementedException();
                }
            }
        }

#endif
    }
}
#endif
#endif