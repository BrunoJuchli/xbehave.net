// <copyright file="ObjectDisposalFeature.cs" company="xBehave.net contributors">
//  Copyright (c) xBehave.net contributors. All rights reserved.
// </copyright>

#if NET40 || NET45
namespace Xbehave.Test.Acceptance
{
    using System;
    using System.Globalization;
    using System.Linq;
#if !V2
    using System.Threading;
#endif
#if NET45
    using System.Threading.Tasks;
#endif
    using FluentAssertions;
    using Xbehave.Test.Acceptance.Infrastructure;
    using Xunit.Abstractions;

    // In order to release allocated resources
    // As a developer
    // I want to register objects for disposal after a scenario has run
    public class ObjectDisposalFeature : Feature
    {
        [Background]
        public void Background()
        {
            "Given no events have occurred"
                .f(() => typeof(ObjectDisposalFeature).ClearTestEvents());
        }

        [Scenario]
        [Example(typeof(AStepWithThreeDisposables))]
#if !V2
        [Example(typeof(AStepWithThreeDisposablesAndATimeout))]
#endif
        [Example(typeof(ThreeStepsWithDisposables))]
#if NET45
        [Example(typeof(AnAsyncStepWithThreeDisposables))]
#endif
        public void ManyDisposablesInASingleStep(Type feature, ITestResultMessage[] results)
        {
            "Given {0}"
                .f(() => { });

            "When running the scenario"
                .f(() => results = this.Run<ITestResultMessage>(feature));

            "And there should be no failures"
                .f(() => results.Should().ContainItemsAssignableTo<ITestPassed>());

#if !V2
            "And all but the last result should not be generated by a teardown"
                .f(() => results.Reverse().Skip(1).Should().NotContain(
                    result => result.Test.DisplayName.IndexOf("(Teardown)", StringComparison.OrdinalIgnoreCase) >= 0));

            "And the last result should be generated by a teardown"
                .f(() => results.Last().Test.DisplayName.Should().Contain("(Teardown)"));
#endif

            "And the disposables should each have been disposed in reverse order"
                .f(() => typeof(ObjectDisposalFeature).GetTestEvents()
                    .Should().Equal("disposed3", "disposed2", "disposed1"));
        }

        [Scenario]
        public void ADisposableWhichThrowExceptionsWhenDisposed(Type feature, ITestResultMessage[] results)
        {
            "Given a step with three disposables which throw exceptions when disposed"
                .f(() => feature = typeof(StepWithThreeBadDisposables));

            "When running the scenario"
                .f(() => results = this.Run<ITestResultMessage>(feature));

            "Then the there should be at least two results"
                .f(() => results.Length.Should().BeGreaterOrEqualTo(2));

            "And the first n-1 results should be passes"
                .f(() => results.Reverse().Skip(1).Should().ContainItemsAssignableTo<ITestPassed>());

            "And the last result should be a failure"
                .f(() => results.Reverse().First().Should().BeAssignableTo<ITestFailed>());

            "And the disposables should be disposed in reverse order"
                .f(() => typeof(ObjectDisposalFeature).GetTestEvents()
                    .Should().Equal("disposed3", "disposed2", "disposed1"));
        }

#if !V2
        [Scenario]
        public void DisposablesWhichCreateNewDisposablesWhenDisposed(
            Type feature, ITestResultMessage[] results)
        {
            ("Given a step with disposables which, when disposed," +
                "throw an exception and add more disposables which throw an exception when disposed")
                .f(() => feature = typeof(StepWithThreeRecursiveBadDisposables));

            "When running the scenario"
                .f(() => results = this.Run<ITestResultMessage>(feature));

            "Then the results should not be empty"
                .f(() => results.Should().NotBeEmpty());

            "And the first n-2 results should not be failures"
                .f(() => results.Reverse().Skip(2).Should().NotContain(result => result is ITestFailed));

            "And the last 2 results should be failures"
                .f(() => results.Reverse().Take(2).Should().ContainItemsAssignableTo<ITestFailed>());

            "And the disposables should be disposed in reverse order"
                .f(() => typeof(ObjectDisposalFeature).GetTestEvents()
                    .Should().Equal("disposed3", "disposed2", "disposed1"));
        }

        [Scenario]
        public void MultipleContexts(Type feature, ITestResultMessage[] results)
        {
            "Given a step with a disposable and steps which generate two contexts"
                .f(() => feature = typeof(TwoContexts));

            "When running the scenario"
                .f(() => results = this.Run<ITestResultMessage>(feature));

            "And there should be no failures"
                .f(() => results.Should().ContainItemsAssignableTo<ITestPassed>());

            "And the disposable should be disposed after each context"
                .f(() => typeof(ObjectDisposalFeature).GetTestEvents()
                    .Should().Equal("step1", "disposed1", "step2", "disposed2"));
        }
#endif

        [Scenario]
        [Example(typeof(StepsFollowedByAFailingStep))]
        [Example(typeof(StepFailsToComplete))]
        public void FailingSteps(Type feature, ITestResultMessage[] results)
        {
            "Given {0}"
                .f(() => { });

            "When running the scenario"
                .f(() => results = this.Run<ITestResultMessage>(feature));

            "Then there should be one failure"
                .f(() => results.OfType<ITestFailed>().Count().Should().Be(1));

            "And the disposables should be disposed in reverse order"
                .f(() => typeof(ObjectDisposalFeature).GetTestEvents()
                    .Should().Equal("disposed3", "disposed2", "disposed1"));
        }

        [Scenario]
        public void DisposablesAndTeardowns(Type feature, ITestResultMessage[] results)
        {
            "Given steps with disposables and teardowns"
                .f(() => feature = typeof(StepsWithDisposablesAndTeardowns));

            "When running the scenario"
                .f(() => results = this.Run<ITestResultMessage>(feature));

            "And there should be no failures"
                .f(() => results.Should().ContainItemsAssignableTo<ITestPassed>());

            "And the disposables and teardowns should be disposed/executed in reverse order"
                .f(() => typeof(ObjectDisposalFeature).GetTestEvents()
                    .Should().Equal("teardown4", "disposed3", "teardown2", "disposed1"));
        }

        [Scenario]
        public void NullDisposable()
        {
            "Given a null body"
                .f(c => ((IDisposable)null).Using(c));
        }

        private static class AStepWithThreeDisposables
        {
            [Scenario]
            public static void Scenario(
                Disposable disposable0, Disposable disposable1, Disposable disposable2)
            {
                "Given some disposables"
                    .f(c =>
                    {
                        disposable0 = new Disposable(1).Using(c);
                        disposable1 = new Disposable(2).Using(c);
                        disposable2 = new Disposable(3).Using(c);
                    });

                "When using the disposables"
                    .f(() =>
                    {
                        disposable0.Use();
                        disposable1.Use();
                        disposable2.Use();
                    });
            }
        }

#if !V2
        private static class AStepWithThreeDisposablesAndATimeout
        {
            [Scenario]
            public static void Scenario(
                Disposable disposable0, Disposable disposable1, Disposable disposable2)
            {
                "Given some disposables"
                    .f(c =>
                    {
                        disposable0 = new Disposable(1).Using(c);
                        disposable1 = new Disposable(2).Using(c);
                        disposable2 = new Disposable(3).Using(c);
                    })
                    .WithTimeout(Timeout.Infinite);

                "When using the disposables"
                    .f(() =>
                    {
                        disposable0.Use();
                        disposable1.Use();
                        disposable2.Use();
                    });
            }
        }
#endif

        private static class StepWithThreeBadDisposables
        {
            [Scenario]
            public static void Scenario(
                Disposable disposable0, Disposable disposable1, Disposable disposable2)
            {
                "Given some disposables"
                    .f(c =>
                    {
                        disposable0 = new BadDisposable(1).Using(c);
                        disposable1 = new BadDisposable(2).Using(c);
                        disposable2 = new BadDisposable(3).Using(c);
                    });

                "When using the disposables"
                    .f(() =>
                    {
                        disposable0.Use();
                        disposable1.Use();
                        disposable2.Use();
                    });
            }
        }

#if !V2
        private static class StepWithThreeRecursiveBadDisposables
        {
            [Scenario]
            public static void Scenario(
                Disposable disposable0, Disposable disposable1, Disposable disposable2)
            {
                "Given some disposables"
                    .f(c =>
                    {
                        disposable0 = new RecursiveBadDisposable(1).Using(c);
                        disposable1 = new RecursiveBadDisposable(2).Using(c);
                        disposable2 = new RecursiveBadDisposable(3).Using(c);
                    });

                "When using the disposables"
                    .f(() =>
                    {
                        disposable0.Use();
                        disposable1.Use();
                        disposable2.Use();
                    });
            }
        }

#endif
        private static class ThreeStepsWithDisposables
        {
            [Scenario]
            public static void Scenario(
                Disposable disposable0, Disposable disposable1, Disposable disposable2)
            {
                "Given a disposable"
                    .f(c => disposable0 = new Disposable(1).Using(c));

                "And another disposable"
                    .f(c => disposable1 = new Disposable(2).Using(c));

                "And another disposable"
                    .f(c => disposable2 = new Disposable(3).Using(c));

                "When using the disposables"
                    .f(() =>
                    {
                        disposable0.Use();
                        disposable1.Use();
                        disposable2.Use();
                    });
            }
        }

#if !V2
        private static class TwoContexts
        {
            private static int context;

            [Scenario]
            public static void Scenario(Disposable disposable)
            {
                "Given a disposable"
                    .f(c =>
                    {
                        context++;
                        var @event = string.Concat("step", context.ToString(CultureInfo.InvariantCulture));
                        typeof(ObjectDisposalFeature).SaveTestEvent(@event);
                        disposable = new Disposable(context).Using(c);
                    });

                "When using the disposable"
                    .f(() => disposable.Use());

                "Then something"
                    .f(() => { })
                    .InIsolation();

                "And something"
                    .f(() => { });
            }
        }
#endif

        private static class StepsFollowedByAFailingStep
        {
            [Scenario]
            public static void Scenario(
                Disposable disposable0, Disposable disposable1, Disposable disposable2)
            {
                "Given a disposable"
                    .f(c => disposable0 = new Disposable(1).Using(c));

                "And another disposable"
                    .f(c => disposable1 = new Disposable(2).Using(c));

                "And another disposable"
                    .f(c => disposable2 = new Disposable(3).Using(c));

                "When using the disposables"
                    .f(() =>
                    {
                        disposable0.Use();
                        disposable1.Use();
                        disposable2.Use();
                    });

                "Then something happens"
                    .f(() => 1.Should().Be(0));
            }
        }

        private static class StepFailsToComplete
        {
            [Scenario]
            public static void Scenario()
            {
                "Given some disposables"
                    .f(c =>
                    {
                        new Disposable(1).Using(c);
                        new Disposable(2).Using(c);
                        new Disposable(3).Using(c);
                        throw new InvalidOperationException();
                    });
            }
        }

#if NET45
        private static class AnAsyncStepWithThreeDisposables
        {
            [Scenario]
            public static void Scenario(
                Disposable disposable0, Disposable disposable1, Disposable disposable2)
            {
                "Given some disposables"
                    .f(async c =>
                    {
                        await Task.Yield();
                        disposable0 = new Disposable(1).Using(c);
                        disposable1 = new Disposable(2).Using(c);
                        disposable2 = new Disposable(3).Using(c);
                    });

                "When using the disposables"
                    .f(() =>
                    {
                        disposable0.Use();
                        disposable1.Use();
                        disposable2.Use();
                    });
            }
        }
#endif

        private static class StepsWithDisposablesAndTeardowns
        {
            [Scenario]
            public static void Scenario()
            {
                "Given something"
                    .f(c => new Disposable(1).Using(c))
                    .Teardown(() => typeof(ObjectDisposalFeature).SaveTestEvent("teardown2"));

                "And something else"
                    .f(c => new Disposable(3).Using(c))
                    .Teardown(() => typeof(ObjectDisposalFeature).SaveTestEvent("teardown4"));
            }
        }

        private class Disposable : IDisposable
        {
            private readonly int number;
            private bool isDisposed;

            public Disposable(int number)
            {
                this.number = number;
            }

            ~Disposable()
            {
                this.Dispose(false);
            }

            public void Use()
            {
                if (this.isDisposed)
                {
                    throw new ObjectDisposedException(this.GetType().FullName);
                }
            }

            public void Dispose()
            {
                this.Dispose(true);
                GC.SuppressFinalize(this);
            }

            protected virtual void Dispose(bool disposing)
            {
                if (disposing)
                {
                    var @event = string.Concat("disposed", this.number.ToString(CultureInfo.InvariantCulture));
                    typeof(ObjectDisposalFeature).SaveTestEvent(@event);
                    this.isDisposed = true;
                }
            }
        }

        private sealed class BadDisposable : Disposable
        {
            public BadDisposable(int number)
                : base(number)
            {
            }

            protected override void Dispose(bool disposing)
            {
                base.Dispose(disposing);
                if (disposing)
                {
                    throw new NotImplementedException();
                }
            }
        }

#if !V2
        private sealed class RecursiveBadDisposable : Disposable
        {
            public RecursiveBadDisposable(int number)
                : base(number)
            {
            }

            protected override void Dispose(bool disposing)
            {
                base.Dispose(disposing);
                if (disposing)
                {
#pragma warning disable 618
                    new BadDisposable(1).Using();
#pragma warning restore 618
                    throw new NotImplementedException();
                }
            }
        }

#endif
    }
}
#endif
