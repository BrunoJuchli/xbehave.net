// <copyright file="TeardownFeature.cs" company="xBehave.net contributors">
//  Copyright (c) xBehave.net contributors. All rights reserved.
// </copyright>

#if NET40 || NET45
namespace Xbehave.Test.Acceptance
{
    using System;
    using System.Globalization;
    using System.IO;
    using System.Linq;
    using System.Threading;
    using FluentAssertions;
    using Xbehave.Test.Acceptance.Infrastructure;

    // In order to release allocated resources
    // As a developer
    // I want to execute teardowns after a scenario has run
    public static class TeardownFeature
    {
        [Background]
        public static void Background()
        {
            "Given no temporary files exist"
                .f(() =>
                {
                    foreach (var path in Directory.EnumerateFiles(Directory.GetCurrentDirectory(), "*.TeardownFeature"))
                    {
                        File.Delete(path);
                    }
                });
        }

        [Scenario]
        public static void ManyTeardownsInASingleStep(Type feature, Result[] results)
        {
            "Given a step with many teardowns"
                .f(() => feature = typeof(StepWithManyTeardowns));

            "When running the scenario"
                .f(() => results = feature.RunScenarios());

            "Then there should be two results"
                .f(() => results.Length.Should().Be(2));

            "And there should be no failures"
                .f(() => results.Should().ContainItemsAssignableTo<Pass>());

            "And the first result should be generated by the step"
                .f(() => results[0].ShouldNotBeATeardown());

            "And the second result should be generated by the teardown"
                .f(() => results[1].ShouldBeATeardown());

            "Ann the teardowns should be executed in reverse order after the step"
                .f(() => ShouldBeWrittenInOrder(
                    "step.1.TeardownFeature", 
                    "teardown.3.TeardownFeature", 
                    "teardown.2.TeardownFeature",
                    "teardown.1.TeardownFeature"));
        }

        [Scenario]
        public static void TeardownsWhichThrowExceptionsWhenExecuted(Type feature, Result[] results)
        {
            "Given a step with three teardowns which throw exceptions when executed"
                .f(() => feature = typeof(StepWithThreeBadTeardowns));

            "When running the scenario"
                .f(() => results = feature.RunScenarios());

            "Then there should be two results"
                .f(() => results.Length.Should().Be(2));

            "And the first result should be a pass"
                .f(() => results[0].Should().BeOfType<Pass>());

            "And the second result should be a failure"
                .f(() => results[1].Should().BeOfType<Fail>());

            "Then the teardowns should be executed in reverse order after the step"
                .f(() => ShouldBeWrittenInOrder(
                    "step.1.TeardownFeature", 
                    "teardown.3.TeardownFeature",
                    "teardown.2.TeardownFeature",
                    "teardown.1.TeardownFeature"));
        }

        [Scenario]
        public static void ManyTeardownsInManySteps(Type feature, Result[] results)
        {
            "Given two steps with three teardowns each"
                .f(() => feature = typeof(TwoStepsWithThreeTeardownsEach));

            "When running the scenario"
                .f(() => results = feature.RunScenarios());

            "Then there should be four results"
                .f(() => results.Length.Should().Be(3));

            "And there should be no failures"
                .f(() => results.Should().ContainItemsAssignableTo<Pass>());

            "And the teardowns should be executed in reverse order after the steps"
                .f(() => ShouldBeWrittenInOrder(
                    "step.1.TeardownFeature",
                    "step.2.TeardownFeature",
                    "teardown.6.TeardownFeature",
                    "teardown.5.TeardownFeature",
                    "teardown.4.TeardownFeature",
                    "teardown.3.TeardownFeature",
                    "teardown.2.TeardownFeature",
                    "teardown.1.TeardownFeature"));
        }

#if !V2
        [Scenario]
        public static void MultipleContexts(Type feature, Result[] results)
        {
            "Given a step with a teardown and steps which generate two contexts"
                .f(() => feature = typeof(SingleStepTwoContexts));

            "When running the scenario"
                .f(() => results = feature.RunScenarios());

            "Then there should be no failures"
                .f(() => results.Should().ContainItemsAssignableTo<Pass>());

            "And the teardown should be executed after each context"
                .f(() => ShouldBeWrittenInOrder(
                    "step.1.1.TeardownFeature",
                    "step.1.2.TeardownFeature",
                    "step.1.3.TeardownFeature",
                    "teardown.1.1.TeardownFeature",
                    "step.2.1.TeardownFeature",
                    "step.2.2.TeardownFeature",
                    "step.2.4.TeardownFeature",
                    "teardown.2.1.TeardownFeature"));
        }
#endif

        [Scenario]
        public static void FailingSteps(Type feature, Result[] results)
        {
            "Given two steps with teardowns and a failing step"
                .f(() => feature = typeof(TwoStepsWithTeardownsAndAFailingStep));

            "When running the scenario"
                .f(() => results = feature.RunScenarios());

            "Then there should be one failure"
                .f(() => results.OfType<Fail>().Count().Should().Be(1));

            "And the teardowns should be executed after each step"
                .f(() => ShouldBeWrittenInOrder(
                    "step.1.TeardownFeature",
                    "step.2.TeardownFeature",
                    "step.3.TeardownFeature",
                    "teardown.2.TeardownFeature",
                    "teardown.1.TeardownFeature"));
        }

        [Scenario]
        public static void FailureToCompleteAStep(Type feature, Result[] results)
        {
            "Given a failing step with three teardowns"
                .f(() => feature = typeof(FailingStepWithThreeTeardowns));

            "When running the scenario"
                .f(() => results = feature.RunScenarios());

            "Then there should be one failure"
                .f(() => results.OfType<Fail>().Count().Should().Be(1));

            "And the teardowns should be executed in reverse order after the step"
                .f(() => ShouldBeWrittenInOrder(
                    "step.1.TeardownFeature",
                    "teardown.3.TeardownFeature",
                    "teardown.2.TeardownFeature",
                    "teardown.1.TeardownFeature"));
        }

        private static void ShouldBeWrittenInOrder(params string[] paths)
        {
            Directory.EnumerateFiles(Directory.GetCurrentDirectory(), "*.TeardownFeature").Select(Path.GetFileName)
                .Should().BeEquivalentTo(paths);

            var writings = paths.Select(s => new { Path = s, Ticks = Read(s) }).ToArray();
            writings.Should().Equal(writings.OrderBy(writing => writing.Ticks));
        }

        private static AndConstraint<FluentAssertions.Primitives.StringAssertions> ShouldNotBeATeardown(
            this Result result)
        {
            return result.DisplayName.Should().NotContainEquivalentOf("(teardown)");
        }

        private static AndConstraint<FluentAssertions.Primitives.StringAssertions> ShouldBeATeardown(
            this Result result)
        {
            return result.DisplayName.Should().ContainEquivalentOf("(teardown)");
        }

        private static void Write(string path)
        {
            Thread.Sleep(1);
            using (var file = new StreamWriter(path, false))
            {
                file.Write(DateTime.Now.Ticks.ToString(CultureInfo.InvariantCulture));
            }
        }

        private static long Read(string path)
        {
            return long.Parse(File.ReadAllText(path), CultureInfo.InvariantCulture);
        }

        private static class StepWithManyTeardowns
        {
            [Scenario]
            public static void Scenario()
            {
                "Given something"
                    .f(() => Write("step.1.TeardownFeature"))
                    .Teardown(() => Write("teardown.1.TeardownFeature"))
                    .Teardown(() => Write("teardown.2.TeardownFeature"))
                    .Teardown(() => Write("teardown.3.TeardownFeature"));
            }
        }

        private static class StepWithThreeBadTeardowns
        {
            [Scenario]
            public static void Scenario()
            {
                "Given something"
                    .f(() => Write("step.1.TeardownFeature"))
                    .Teardown(() =>
                    {
                        Write("teardown.1.TeardownFeature");
                        throw new InvalidOperationException();
                    })
                    .Teardown(() =>
                    {
                        Write("teardown.2.TeardownFeature");
                        throw new InvalidOperationException();
                    })
                    .Teardown(() =>
                    {
                        Write("teardown.3.TeardownFeature");
                        throw new InvalidOperationException();
                    });
            }
        }

        private static class TwoStepsWithThreeTeardownsEach
        {
            [Scenario]
            public static void Scenario()
            {
                "Given something"
                    .f(() => Write("step.1.TeardownFeature"))
                    .Teardown(() => Write("teardown.1.TeardownFeature"))
                    .Teardown(() => Write("teardown.2.TeardownFeature"))
                    .Teardown(() => Write("teardown.3.TeardownFeature"));

                "And something else"
                    .f(() => Write("step.2.TeardownFeature"))
                    .Teardown(() => Write("teardown.4.TeardownFeature"))
                    .Teardown(() => Write("teardown.5.TeardownFeature"))
                    .Teardown(() => Write("teardown.6.TeardownFeature"));
            }
        }

#if !V2
        private static class SingleStepTwoContexts
        {
            private static int context;

            [Scenario]
            public static void Scenario()
            {
                "Given something"
                    .f(() =>
                    {
                        ++context;
                        Write(
                            string.Concat("step.", context.ToString(CultureInfo.InvariantCulture), ".1.TeardownFeature"));
                    })
                    .Teardown(() => Write(
                        string.Concat("teardown.", context.ToString(CultureInfo.InvariantCulture), ".1.TeardownFeature")));

                "When something happens"
                    .f(() => Write(
                        string.Concat("step.", context.ToString(CultureInfo.InvariantCulture), ".2.TeardownFeature")));

                "Then something"
                    .f(() => Write(
                        string.Concat("step.", context.ToString(CultureInfo.InvariantCulture), ".3.TeardownFeature")))
                    .InIsolation();

                "And something"
                    .f(() => Write(
                        string.Concat("step.", context.ToString(CultureInfo.InvariantCulture), ".4.TeardownFeature")));
            }
        }
#endif

        private static class TwoStepsWithTeardownsAndAFailingStep
        {
            [Scenario]
            public static void Scenario()
            {
                "Given something"
                    .f(() => Write("step.1.TeardownFeature"))
                    .Teardown(() => Write("teardown.1.TeardownFeature"));

                "When something"
                    .f(() => Write("step.2.TeardownFeature"))
                    .Teardown(() => Write("teardown.2.TeardownFeature"));

                "Then something happens"
                    .f(() =>
                    {
                        Write("step.3.TeardownFeature");
                        1.Should().Be(0);
                    });
            }
        }

        private static class FailingStepWithThreeTeardowns
        {
            [Scenario]
            public static void Scenario()
            {
                "Given something"
                    .f(() =>
                    {
                        Write("step.1.TeardownFeature");
                        throw new InvalidOperationException();
                    })
                    .Teardown(() => Write("teardown.1.TeardownFeature"))
                    .Teardown(() => Write("teardown.2.TeardownFeature"))
                    .Teardown(() => Write("teardown.3.TeardownFeature"));
            }
        }
    }
}
#endif
